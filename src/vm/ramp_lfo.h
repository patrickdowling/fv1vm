// fv1vm: experimental FV-1 virtual machine
// Copyright (C) 2022 Patrick Dowling <pld@gurkenkiste.com>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

#ifndef FV1_RAMP_H_
#define FV1_RAMP_H_

#include "fv1/fv1_opcodes.h"
#include "lfo.h"

namespace fv1 {

// RAMP LFO
// NOTE rate (-16384, 32768]
//
// 0x3fffff = 22 bits so (in theory) you get the 12 (4096) + 10 fractional bits?
// This is also 0x7fffff >> 1 which is 0.5
//
// The ramp is basically generated by subtracting the rate from max value (0x3fffff), modulo amp,
// rinse repeat. Empirically this is off by a factor of 16 where we get ~16Hz at 32767.
// 0x3fffff / (32767 / 16) = 2048, 32K/2048 = ~16
//
// We have to shift the register value by 8 (23 - 15) to convert from fixed point, then >> 4 for
// /16. This does mean rate values of between -16 and 16 are "lost". This is hard to verify since
// the audio outputs (e.g. on Dervish) are AC coupled but fits with the general description of
// "0.5Hz" = 8/16. We can however keep the phase_ in 24 bits and convert the final result. This
// gives a maximum period of 8x16s.
//
// - Decreasing amplitude = higher frequency which is also confirmed using hardware (see docs).
// - RMPx_RANGE register seems to be shifted, 0x200000=2048, 0x400000=1024, 0x600000=512=128Hz
//
// TODO It'd seem to make sense to offload the actual calculations to the math/engine.
// TODO What's the downside to pre-calculating value/rptr2_value (or everything) in Tick?
// TODO Related to above: Seems like is skirting around the exact details of the REG flag.
// TODO Naming? range/amp freq/rate...
// TODO Check ramp coefficient (esp. SOF) if it's the fractional part, or the ramp 0-1.0?
// AN-0001 "Similarly to the SIN LFO there are fractional bits below those used for address offset
// that can be used for linear interpolation."

template <typename Engine>
class RampLfoImpl : public LfoBase<Engine> {
public:
  static constexpr int32_t kRateShift = 23 - 15;
  static constexpr int32_t kRangeShift = 23 - 2;
  static constexpr int32_t kAmp4096 = 0x3fffff;
  using value_type = typename LfoBase<Engine>::LfoValue;

  RampLfoImpl() = delete;
  RampLfoImpl(const typename Engine::Register *rate, const typename Engine::Register *range)
      : LfoBase<Engine>(rate, range)
  {}

  void Jam() { phase_ = 0; }

  int32_t range() const { return kAmp4096 >> amp_shift(); }

  void Tick()
  {
    auto rate = this->rate_->loadi() >> kRateShift;
    phase_ = (phase_ - (rate >> 4)) & range();
  }

  SF23 value() const { return SF23{phase_}; }

  // VALID: REG COMPC COMPA RPTR2 NA
  value_type Read(const CHO_FLAGS flags) const
  {
    if (CHO_FLAGS::NA & flags) {
      // RPTR2 has no effect on NA
      auto coefficient = crossfade();
      if (CHO_FLAGS::COMPC & flags) coefficient = Engine::ONE - coefficient;
      return value_type{0, coefficient};
    } else {
      const auto r = range();
      int32_t v = phase_;
      if (CHO_FLAGS::RPTR2 & flags) v = (v + (r >> 1)) & r;
      auto coefficient = Engine::template LfoCoeffToFloat<10>(v & 0x3ff);
      if (CHO_FLAGS::COMPA & flags) v = r - v;
      if (CHO_FLAGS::COMPC & flags) coefficient = Engine::ONE - coefficient;
      return value_type{v >> 10, coefficient};
    }
  }

  // TODO Does crossfade go from 0-.5 or 0-1.? v goes from 0.25 at 4096
  // TODO Hardware appears to generate _/^\_ instead of a triangle
  typename Engine::float_type crossfade() const
  {
    auto v = phase_;
    auto r = range();
    v = (v > r / 2) ? r - v : v;
    return v << (2 + amp_shift());
  }

private:
  int32_t phase_ = 0;

  inline int32_t amp_shift() const { return this->range_->loadi() >> kRangeShift; }
};

}  // namespace fv1

#endif  // FV1_RAMP_H_
